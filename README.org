#+title: Literate Dotfiles

These are my /literate/ dotfiles. To compile and deploy these files you need to
run ~(org-bable-tangle)~. There are no additional settings that are needed to
tangle this. Running the above command will create all the needed directories
and files, and compile the configs specified here and deploy them to the right
locations. To update a config file, make the edits and then run the same
~(org-bable-tangle)~ function to update. Because of the ~:cache yes~ directive,
Org-Babel will only change files if there are changes.

* Log
** <2022-08-18 Thu>
I'm trying to decide how to incorporate my doom config into this. I /really/
want to be /orgish/ and use one file for all my configurations. I suspect that
might not eventually and ultimately be what I do though. Nonetheless, I can try!

I'm also not sure if I /want/ to use the ~README.org~ for my config, but it does
have the advantage of being displayed automatically by nearly all VCS GUIs in
the world.

* Configurations
** Boilerplate
This is a brief header explaining that these files are generated with org-babel
and should not be directly edited. This block doesn't actually do anything by
itself, but it can be included in other files by including it in other blocks
with ~<<boilerplate-file-header>>~.
#+name: boilerplate-file-header
#+begin_src sh :tangle no
# This file was generated from a literate dotfiles config.
# This file should not be directly edited. Instead edit
# the literate-dotfiles repo and then tangle the file.
# The repo can be found at:
# https://github.com/pard68/literate-dotfiles
#+end_src

** Shell
First let's setup the various ZSH files that the shell expects. We like A S T H
E T I C home directories, so we're going to hide our ZSH config files in the
~\~/.config/~ dir like the good Lord intended.

*** Environment Variables
:PROPERTIES:
:header-args: :tangle ~/.zshenv :comments link :mkdirp yes :padline no :noweb tangle :cache yes
:END:
Sadly, ZSH sorta sucks and the ~.zshenv~ has to live in the home directory, so
we're going to set that up and tell it to look in ~.config/zsh/~ for all the
rest of the zsh config files we might use. So we'll setup the zshenv file to
have all the right XDG settings, plus point all the various other things that
need to be told to use .config to do so.

First let's add the boilderplate header to this file:
#+begin_src sh :comments no
<<boilerplate-file-header>>
#+end_src
**** XDG and Zsh paths
#+begin_src sh
export XDG_CONFIG_HOME="$HOME/.config"
export XDG_DATA_HOME="$HOME/.local/share"
export XDG_DATA_HOME="$HOME/.cache/"
export ZDOTDIR="$XDG_CONFIG_HOME/zsh"
export HISTFILE="$ZDOTDIR/zhistory"

export DOOM_EMACS=$XDG_CONFIG_HOME/emacs
export DOOMDIR=$XDG_CONFIG_HOME/doom
#+end_src

**** HIST
We want to make sure our history is nice and long. It's 2022, so we shouldn't
worry too much about disk space or RAM... I hope

#+begin_src sh
export HISTSIZE=10000
export SAVEHIST=10000
#+end_src

**** EDITOR
Let's set our editor quickly so we can make sure we're never far away from
emacs.

#+begin_src sh
export EDITOR="/usr/local/bin/emacsclient"
export VISUAL="/usr/local/bin/emacsclient"
export ALTERNATE_EDITOR="/usr/local/bin/nvim"
#+end_src

**** $PATH
We'll setup some ~$PATH~ stuff now too. I really hate editing one-liner ~$PATH~
exports, so we'll just do one per line, why not? Maybe there is a cool way to
use org and iterate over a list of path values and concatenate them together,
but IDK how to do that right now...

#+begin_src sh
export PATH="$HOME/.cargo/bin:$PATH"
export PATH="$HOME/go/bin:$PATH"
export PATH="$HOME/.local/bin:$PATH"
export PATH="/usr/local/bin:$PATH"
export PATH="/usr/bin:$PATH"
export PATH="/bin:$PATH"
export PATH="/usr/local/sbin:$PATH"
export PATH="/usr/local/go/bin/:$PATH"
export PATH="$XDG_CONFIG_HOME/emacs/bin/:$PATH"
export PATH="$HOME/.npm-global/bin:$PATH"
#+end_src

*** Zshrc
:PROPERTIES:
:header-args: :tangle ~/.config/zsh/.zshrc :comments link :mkdirp yes :padline no :noweb tangle :cache yes
:END:

The zshrc file has to be prefixed with a ~.~ for Zsh to pick it up. It sorta sucks... but it's whatever I'll never really interact with that file.

First let's add the boilderplate header to this file:
#+begin_src sh :comments no
<<boilerplate-file-header>>
#+end_src
**** A E S T H E T I C

Your terminal, in Technicolor!
#+begin_src sh
autoload -U colors && colors
PROMPT="(%B%T%b) %B%F{magenta}Î»%f%b "
#+end_src
**** Zsh Options

[[https://zsh.sourceforge.io/Doc/Release/Options.html][Here]] is a list of all the zsh options that can be set.
#+begin_src sh
setopt HIST_SAVE_NO_DUPS
setopt INC_APPEND_HISTORY
setopt HIST_IGNORE_SPACE

setopt AUTO_CD
setopt AUTO_PUSHD
setopt PUSHD_IGNORE_DUPS
setopt PUSHD_SILENT

REPORTTIME=3
#+end_src

**** Ghetto Jump

There are some neat "jump" plugins like ~j~ and ~z~. But we're just going to DIWhy it!
#+begin_src sh
alias d='dirs -v'
for index ({1..9}) alias "$index"="cd + ${index}"; unset index
#+end_src

**** Completion

#+begin_src sh
autoload -U compinit
zstyle ':completion:*' menu select completer _complete _correct _approximate
zmodload zsh/complist
compinit
_comp_options+=(globdots)
#+end_src

*** Aliases
:PROPERTIES:
:header-args: :tangle ~/.config/zsh/aliases :comments link :mkdirp yes :padline no :noweb tangle :cache yes
:END:
Before we make an alias file, let's source them from the zshrc file.
#+begin_src sh :tangle ~/.config/zsh/.zshrc
source $ZDOTDIR/aliases
#+end_src

Okay, now onto the aliases file. First let's add the boilderplate header to this file:
#+begin_src sh :comments no
<<boilerplate-file-header>>
#+end_src

**** Clear
#+begin_src sh
alias c!=clear
#+end_src
**** Git
#+begin_src sh
alias g=git
alias ga="git add"
alias ga.="git add ."
alias gb="git branch"
alias gbd="git branch -D"
alias gc="git commit"
alias gcm="git commit -m"
alias gca="git commit --amend"
alias gcm!!="git add .; git commit -m "Update!"; git push"
alias gcl="git clone"
alias gco="git checkout"
alias gd="git diff"
alias gl="git log"
alias gm="git merge"
alias gpl="git pull"
alias gps="git push"
alias gps!="git push --force"
alias gpsu="git push -u origin master"
alias gri="git rebase -i"
alias gs="git status"
#+end_src
**** ls
#+begin_src sh
alias l="ls"
alias la="ls -a"
alias ll="ls -l"
alias lla="ls -la"
#+end_src
**** mbsync
#+begin_src sh
alias mbsync="mbsync -c ~/.config/isync/mbsyncrc"
#+end_src
** Kitty
:PROPERTIES:
:header-args: :tangle ~/.config/kitty/kitty.conf :comments link :mkdirp yes :padline no :noweb tangle :cache yes
:END:

Kitty is the terminal. I prefer to use. I don't use it much, with emacs around,
but sometimes it's nice to have a real terminal. Before we start, let's add the
boilerplate file header:
#+begin_src sh :comments no
<<boilerplate-file-header>>
#+end_src
*** Font
Set the font
#+begin_src conf
font_family scientifica
font_size 16.0
#+end_src
*** Default Options
#+begin_src conf
open_url_with default
enable_audio_bell no
tab_bar_style powerline
background_opacity 0.9
#+end_src
*** Mappings
#+begin_src conf
map ctrl+h neighboring_window left
map ctrl+j neighboring_window down
map ctrl+k neighboring_window up
map ctrl+l neighboring_window right
map ctrl+] next_tab
map ctrl+[ previious_tab
#+end_src
*** Theme
:PROPERTIES:
:header-args: :tangle ~/.config/kitty/theme.conf :comments link :mkdirp yes :padline no :noweb tangle :cache yes
:END:
Set the theme we'll use
#+begin_src conf :tangle ~/.config/kitty/kitty.conf
include theme.conf
#+end_src

And then define that theme. This is not something I created. I got it from [[https://github.com/mcchrish/zenbones.nvim/raw/main/extras/kitty/zenbones_dark.conf][here]].
#+begin_src conf :comments no
<<boilerplate-file-header>>
#+end_src

***** Background and Foreground Colors
#+begin_src conf
foreground                      #B4BDC3
background                      #1C1917
selection_foreground            #B4BDC3
selection_background            #3D4042
#+end_src
***** Cursor Colors
#+begin_src conf
cursor                          #C4CACF
cursor_text_color               #1C1917
#+end_src
***** Tab Colors
#+begin_src conf
active_tab_foreground           #B4BDC3
active_tab_background           #65435E
inactive_tab_foreground         #B4BDC3
inactive_tab_background         #352F2D
#+end_src
***** Color Definitions
****** Black
#+begin_src conf
color0 #1C1917
color8 #403833
#+end_src
****** Red
#+begin_src conf
color1 #DE6E7C
color9 #E8838F
#+end_src
****** Green
#+begin_src conf
color2  #819B69
color10 #8BAE68
#+end_src
****** Yellow
#+begin_src conf
color3  #B77E64
color11 #D68C67
#+end_src
****** Blue
#+begin_src conf
color4  #6099C0
color12 #61ABDA
#+end_src
****** Magenta
#+begin_src conf
color5  #B279A7
color13 #CF86C1
#+end_src
****** Cyan
#+begin_src conf
color6  #66A5AD
color14 #65B8C1
#+end_src
****** White
#+begin_src conf
color7  #B4BDC3
color15 #888F94
#+end_src

** Hammerspoon
:PROPERTIES:
:header-args: :tangle ~/.hammerspoon/init.lua :comments link :mkdirp yes :padline no :noweb tangle :cache yes
:END:

I really only want Hammerspoon around on Mac, but I'm not currently sure how to
best add that conditional nature into org-babel. So we'll just install it all
and if it's not Mac... well it'll just never get used. Also, should be noted
that Hammerspoon doesn't seem to respect the XDG stuff and just puts its config
directory in the root of your home dir like a pig.

*** Boilerplate
#+begin_src lua :comments no
--[[
<<boilerplate-file-header>>
--]]
#+end_src

**** Hammerspoon CLI Tool
First thing, let's install the hs cli tool so we can call Hammerspoon from the
terminal if we need to. By default it'll install to the ~/usr/local/bin~.
#+begin_src lua
require'hs.ipc'
hs.ipc.cliInstall()
#+end_src

**** Config Reloader
And let's setup auto reloading for hammerspoon. First the reload function,
stolen from [[https://github.com/wangshub/hammerspoon-config/blob/06ff4db98baa4e568db0f79f3de0c58a578535a2/reload/reload.lua][here]]:
#+begin_src lua
reloadConfig = {
  watcher = {},
}

function reloadConfig.reloader(paths)
  doReload = false
  for _, file in pairs(paths) do
    if file:sub(-4) == ".lua" then
      print("A Lua configuration file has changed. Reloading...")
      doReload = true
    end
  end
  if not doReload then
    print("No Lua configuration files have changed. Skipping reload...")
    return
  end
  hs.reload()
end
#+end_src

And then we register a path watcher, provide a method to stop the watcher, and
then kick it off:
#+begin_src lua
hammerspoonDir = os.getenv("HOME") .. "/.hammerspoon/"

function reloadConfig.init()
  reloadConfig.watcher = hs.pathwatcher.new(hammerspoonDir, reloadConfig.reloader)
end

function reloadConfig.start()
  reloadConfig.watcher:start()
end

function reloadConfig.stop()
  reloadConfig.watcher:stop()
end

reloadConfig.init()
reloadConfig.start()
#+end_src

*** Keybindings
Next let's setup a few default key combos.
#+begin_src lua
local meh = {"ctrl", "alt", "shift"}
local super = {"ctrl", "alt", "cmd"}
local hyper = {"ctrl", "alt", "cmd", "shift"}
#+end_src

I'm lazy, so we're going to setup some abstraction over the default hammerspoon
hotkey function so I have to type even less!
#+begin_src lua
function bk(...)
  hs.hotkey.bind(...)
end
#+end_src

**** yabai keybindings

First, some abstraction to make calling into Yabai a bit simpler -- I stole this
from [[https://github.com/rtauziac/Hammerspoon-Yabai/blob/4c1c130b089a3c8cc87a3f0dcf13ae0ae64b34a0/.hammerspoon/yabai.lua][here]]:
#+begin_src lua
function strToTable(str)
  t = {}
  for word in string.gmatch(str, "[^%s]+") do
    table.insert(t, word)
  end
  return t
end

function runCmd(bin, strArgs)
  args = strToTable(strArgs)
  local t = hs.task.new(bin,
                        function(err, stdout, stderr)
                          print(err, stdout, stderr)
                        end,
                        function(task, stdout, stderr)
                          print(stdout, stderr)
                          return true
                        end, args)
  t:start()
  if tOut then
    print(tOut)
  end
  if tErr then
    print(tErr)
  end
end

function r(b, a)
  return function() runCmd(b, a) end
end

function yabaiCmd(args)
  yBin = "/usr/local/bin/yabai"
  runCmd(yBin, args)
end

function y(a)
  return function() yabaiCmd(a) end
end
#+end_src

And now the hotkeys!

Let's setup a reload hotkey for Yabai:
#+begin_src lua
-- bk(super, "r", "Yabai Reloaded", r("/bin/launchctl", {"kickstart", "-k", "gui/${UID}/homebrew.mxcl.yabai"}))
bk(super, "r", "Yabai: Reloaded", r("/usr/local/bin/brew", "services restart yabai"))
#+end_src

Now some spaces related hotkeys!
#+begin_src lua
bk(super, "n", "Yabai: Created a new space", y("-m space --create"))
#+end_src

It'd be nice to be able to toggle the various layouts:
#+begin_src lua
bk(super, "s", "Yabai: Stacked Layout", y("-m space --layout stack"))
bk(super, "b", "Yabai: BSP Layout", y("-m space --layout bsp"))
bk(super, "f", "Yabai: Floating Layout", y("-m space --layout float"))
#+end_src
How about some stacking related one?!
#+begin_src lua
bk(super, "n", "Yabai: Window", y("-m space --create"))
#+end_src
*** Spoons
**** Bootstrap
***** spoonManager
~spoonManager~ is a tool that lets us install Spoons from within Hammerspoon,
which means we don't need to include the Spoon's source in our literate config!

Let's create a table of spoons we want to manage. It's going to be empty for
now, but entries should include a table name of the spoon and the git repo path of
the spoon like such:
#+begin_src lua :tangle no
{
  spoon = "spoon's name",
  repo = "git repo",
  path = "path relative to hammerspoon's dir", // this is an optional value and if it isn't provided, just install into the Spoons/ dir
}
#+end_src

#+begin_src lua
spoonList = {}
<<stacklineSpoon>>
<<editWithEmacsSpoon>>
#+end_src

And of course, let's create spoonManager and then kick off the install process
#+begin_src lua
spoonManager = {}

function spoonManager:installMaybe()
  if spoonList == nil then
    return
  end
  for _, spoon in pairs(spoonList) do
    install_path = "Spoons/" .. spoon.name .. ".spoon"
    installed = nil
    if spoon.path then
      install_path = spoon.path
      installed, _ = hs.fs.mkdir(spoon.path)
      installed = not installed
      if not installed then
        hs.fs.rmdir(spoon.path)
      end
    else
      installed = hs.spoons.isInstalled(spoon.name)
    end
    if not installed then
      print("Installing " .. spoon.name .. " from repo: " .. spoon.repo)
      hs.alert("Cloning " .. spoon.name .. " repo. This will just take a moment!")
      reloadConfig.stop()
      gitCloneTask =hs.task.new(
        '/usr/bin/git',
        function(_, _, _)
          reloadConfig.start()
        end,
        {"clone", spoon.repo, install_path})
      gitCloneTask:waitUntilExit()
      gitCloneTask:start()
    else
      print(spoon.name .. " already installed!")
    end
  end
end

spoonManager.installMaybe()
#+end_src

**** stackline
This spoon will help us visualize yabai's stacked windows
#+name: stacklineSpoon
#+begin_src lua :tangle no
table.insert(spoonList, {
               name = "stackline",
               repo = "https://github.com/AdamWagner/stackline.git",
               path = "stackline"
})
#+end_src

Stackline isn't technically a spoon but that might be changing, and since I'd rather just pretend it is than write a special case in the ~spoonManager~ just for stackline, we're just gonna have to get a little hacky...
#+begin_src lua
sl = require('stackline')
sl:init()
#+end_src
***** Keybindings
These some bindings someone created to use the same keys for cycling yabai
stacked and non-stacked spaces. I need to convert this to Lua so we can do this
with Hammerspoon.
#+begin_src shell :tangle no
cmd + shift - k : if [ "$(yabai -m query --spaces --space | jq -r '.type')" = "stack" ]; then (yabai -m window --focus stack.next || yabai -m window --focus stack.first); else yabai -m window --focus next || yabai -m window --focus first; fi
cmd + shift - j : if [ "$(yabai -m query --spaces --space | jq -r '.type')" = "stack" ]; then (yabai -m window --focus stack.prev || yabai -m window --focus stack.last); else yabai -m window --focus prev || yabai -m window --focus last; fi
#+end_src
**** Edit With Emacs
This spoon allows me to take any text area and edit that text area with emacs,
and then send the text edited in Emacs back to that textbox when done. This
spoon is from the GitHub user [[https://github.com/dmgerman/editWithEmacs.spoon/][dmgerman]].
#+name: editWithEmacsSpoon
#+begin_src lua :tangle no
table.insert(spoonList, {
               name = "editWithEmacs",
               repo = "https://github.com/dmgerman/editWithEmacs.spoon.git"})
#+end_src
***** Load Spoon and Add Bindings
#+begin_src lua
hs.loadSpoon("editWithEmacs")
if spoon.editWithEmacs then
  local bindings = {
    edit_selection = { hyper, "e" },
    edit_all = { meh, "e" }
  }
  spoon.editWithEmacs:bindHotkeys(bindings)
end
#+end_src
***** hammerspoon.el
For this to work we need to load some elisp with ~(load
"~/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el")~. Make sure to put
that somewhere into your emacs config.

#+begin_src emacs-lisp :tangle ~/.hammerspoon/Spoons/editWithEmacs.spoon/hammerspoon.el
;;; editWithEmacs.el --- communicate with hammerspoon to editWithEmacs anywhere

;; Copyright (C) 2021 Daniel M. German <dmg@turingmachine.org>
;;                             Jeremy Friesen <emacs@jeremyfriesen.com>
;;

;; Author: Daniel M. German <dmg@turingmachine.org>
;;         Jeremy Friesen <emacs@jeremyfriesen.com>
;;
;; Maintainer: Daniel M. German <dmg@turingmachine.org>
;;
;; Keywords: hammerspoon, os x
;; Homepage: https://github.com/dmgerman/editWithEmacs.spoon

;; GNU Emacs is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; GNU Emacs is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; Use emacs and hammerspoon to edit text in any input box in os x
;; See: https://github.com/dmgerman/editWithEmacs.spoon
;;

;;; Code:


(defvar hammerspoon-buffer-mode 'markdown-mode
  "Name of major mode for hammerspoon editing")

(defvar hammerspoon-buffer-name "*hammerspoon_edit*"
  "Name of the buffer used to edit in emacs.")

(defvar hammerspoon-edit-minor-map nil
  "Keymap used in hammer-edit-minor-mode.")
(unless hammerspoon-edit-minor-map
  (let ((map (make-sparse-keymap)))

    (define-key map (kbd "C-c C-c") 'hammerspoon-edit-end)
    (define-key map (kbd "C-c m")   'hammerspoon-toggle-mode)
    (define-key map (kbd "C-c h")   'hammerspoon-test) ;; for testing

    (setq hammerspoon-edit-minor-map map)))

(define-minor-mode hammerspoon-edit-minor-mode
  "Minor mode to help with editing with hammerspoon"

  :global nil
  :lighter   "_hs-edit_"
  :keymap hammerspoon-edit-minor-map

  ;; if disabling `undo-tree-mode', rebuild `buffer-undo-list' from tree so
  ;; Emacs undo can work
  )

(defun hammerspoon-toggle-mode ()
  "Toggle from Markdown Mode to Org Mode."
  (interactive)
  (if (string-equal "markdown-mode" (format "%s" major-mode))
      (org-mode)
    (markdown-mode))
  (hammerspoon-edit-minor-mode))

(defun hammerspoon-do (command)
  "Send Hammerspoon the given COMMAND."
  (interactive "sHammerspoon Command:")
  (setq hs-binary (executable-find "hs"))
  (if hs-binary
      (call-process hs-binary
                    nil 0 nil
                    "-c"
                    command)
    (message "Hammerspoon hs executable not found. Make sure you hammerspoon has loaded the ipc module")))

(defun hammerspoon-alert (message)
  "Show given MESSAGE via Hammerspoon's alert system."
  (hammerspoon-do (concat "hs.alert.show('" message "', 1)")))

(defun hammerspoon-test ()
  "Show a test message via Hammerspoon's alert system.
If you see a message, Hammerspoon is working correctly."
  (interactive)
  (hammerspoon-alert "Hammerspoon test message..."))

(defun hammerspoon-edit-end ()
  "Send, via Hammerspoon, contents of buffer back to originating window."
  (interactive)
  (mark-whole-buffer)
  (call-interactively 'kill-ring-save)
  (hammerspoon-do (concat "spoon.editWithEmacs:endEditing(False)"))
  (previous-buffer))

(defun hammerspoon-edit-begin ()
  "Receive, from Hammerspoon, text to edit in Emacs"
  (interactive)
  (let ((hs-edit-buffer (get-buffer-create hammerspoon-buffer-name)))
    (switch-to-buffer hs-edit-buffer)
    (erase-buffer) ; Ensure we have a clean buffer
    (yank)
    (funcall hammerspoon-buffer-mode)
    (hammerspoon-edit-minor-mode)
    (message "Type C-c C-c to send back to originating window")
    (exchange-point-and-mark)))
#+end_src

** isync/mbsync
:PROPERTIES:
:header-args: :tangle ~/.config/isync/mbsyncrc :comments link :mkdirp yes :padline no :noweb tangle :cache yes
:END:
This is my isync/mbsync config. I'm using the password store for secrets when
applicable.
#+begin_src sh :comments no
<<boilerplate-file-header>>
#+end_src
*** Personal Protonmail Accounts
I have a number of protonmail accounts. They have virtually the same settings,
even the same password. I am not using the password store for the Proton email
accounts because this password is only applicable to the Proton bridge on my
machine and I don't have a concern about storing it in plaintext since it's
already available in plaintext on the machine anyway. I am just storing it in a
txt file so that this is a bit more portable.

There must be a empty line between accounts. So for this to work we need one
empty line at the end of each config. ~org-tangle~ removes trailing whitespace,
so this means we need to add a new line and then an empty comment. There might
be a better way to do this but I am unaware of it.

**** TODO Make this programmatic, so it just needs a list of email addresses

**** ipringle@protonmail.com
#+begin_src sh
IMAPAccount ipringle-protonmail
Host 127.0.0.1
Port 1143
User pard@0x44.pw
PassCmd "cat ~/.config/isync/proton-bridge-password"
SSLType NONE

IMAPStore ipringle-protonmail-remote
Account ipringle-protonmail

MaildirStore ipringle-protonmail-local
Subfolders Verbatim
Path ~/mail/ipringle@protonmail.com/
Inbox ~/mail/ipringle@protonmail.com/INBOX

Channel ipringle-protonmail
Far :ipringle-protonmail-remote:
Near :ipringle-protonmail-local:
Patterns *
CopyArrivalDate yes
Create Both
Expunge Both
SyncState *

#
#+end_src
**** ian@dapringles.com
#+begin_src sh
IMAPAccount ian-dapringles
Host 127.0.0.1
Port 1143
User ian@dapringles.com
PassCmd "cat ~/.config/isync/proton-bridge-password"
SSLType NONE

IMAPStore ian-dapringles-remote
Account ian-dapringles

MaildirStore ian-dapringles-local
Subfolders Verbatim
Path ~/mail/ian@dapringles.com/
Inbox ~/mail/ian@dapringles.com/INBOX

Channel ian-dapringles
Far :ian-dapringles-remote:
Near :ian-dapringles-local:
Patterns *
CopyArrivalDate yes
Create Both
Expunge Both
SyncState *

#
#+end_src
**** pard@0x44.pw
#+begin_src sh
IMAPAccount pard-0x44
Host 127.0.0.1
Port 1143
User pard@0x44.pw
PassCmd "cat ~/.config/isync/proton-bridge-password"
SSLType NONE

IMAPStore pard-0x44-remote
Account pard-0x44

MaildirStore pard-0x44-local
Subfolders Verbatim
Path ~/mail/pard@0x44.pw/
Inbox ~/mail/pard@0x44.pw/INBOX

Channel pard-0x44
Far :pard-0x44-remote:
Near :pard-0x44-local:
Patterns *
CopyArrivalDate yes
Create Both
Expunge Both
SyncState *

#
#+end_src
*** Work Gmail
This is my config for my work gmail account. I'm not tangling this because using
Gmail with mbsync/mu4e is super annoying and I cannot get sending to work for
some reason. Plus we're migrating /away/ from Gmail so it's less important.
#+begin_src sh :tangle no
# ian@hydrobuilder.com
IMAPAccount work-gmail
Host imap.gmail.com
User ian@hydrobuilder.com
PassCmd "pass email/ian@hydrobuilder.com"
AuthMechs LOGIN
SSLType IMAPS

IMAPStore gmail-remote
Account gmail

MaildirStore gmail-local
Path ~/mail/hydrobuilder/
Inbox ~/mail/hydrobuilder/INBOX
Subfolders Verbatim

Channel gmail
Far :gmail-remote:
Near :gmail-local:
CopyArrivalDate yes
Patterns * ![Gmail]* "[Gmail]/Sent Mail" "[Gmail]/Trash"
Create Both
Expunge Both
SyncState *

#
#+end_src

*** Work Outlook
Nothing fancy here, should be noted that the password is an app-password because
of 2fa requirements.
#+begin_src sh
# i.pringle@hbhold.com
IMAPAccount work
Host outlook.office365.com
User i.pringle@hbhold.com
PassCmd "pass email/i.pringle@hbhold.com"
AuthMechs LOGIN
SSLType IMAPS

IMAPStore work-remote
Account work

MaildirStore work-local
Path ~/mail/ipringle@hbhold.com/
Inbox ~/mail/ipringle@hbhold.com/Inbox
Subfolders Verbatim

Channel work
Far :work-remote:
Near :work-local:
Patterns "INBOX" *
CopyArrivalDate yes
Create Both
Sync all
Expunge Both
SyncState *

#
#+end_src
** yabai
:PROPERTIES:
:header-args: :tangle ~/.config/yabai/yabairc :comments link :mkdirp yes :padline no :noweb tangle :cache yes :tangle-mode (identity #o755)
:END:

*** Boilerplate
#+begin_src shell :comments no
#!/usr/bin/env sh
<<boilerplate-file-header>>
#+end_src

Let's make sure yabai is auto-loading the scripting additions on start -- this
requires that we can run ~sudo yabai~ commands without a password.
#+begin_src shell
yabai -m signal --add event=dock_did_restart action="sudo yabai --load-sa"
#+end_src

*** Config
**** Defaults
We're going to just leave the mouse totally out of the picture:
#+begin_src shell
# global settings
yabai -m config mouse_follows_focus          off
yabai -m config focus_follows_mouse          off
#+end_src

And let's make new windows spawn to the right and to the bottom:
#+begin_src shell
yabai -m config window_placement             second_child
#+end_src

Let's make sure floating windows can be sent to the back -- this is the default,
but it's here for clarity:
#+begin_src shell
yabai -m config window_topmost               off
#+end_src

Just because the window is inactive doesn't mean it shouldn't be easily visible,
so we'll turn off opacity and also add a little shadow for depth:
#+begin_src shell
yabai -m config window_opacity               off
yabai -m config window_opacity_duration      0.0
yabai -m config window_shadow                on
#+end_src

Window equity now!
#+begin_src shell
yabai -m config split_ratio                  0.50
yabai -m config auto_balance                 off
#+end_src

Just in case we break down and use a mouse...
#+begin_src shell
yabai -m config mouse_modifier               alt
yabai -m config mouse_action1                move
yabai -m config mouse_action2                resize
#+end_src

The default layout:
#+begin_src shell
yabai -m config layout                       bsp
#+end_src

#+begin_src shell
# SPACEBAR_HEIGHT=$(spacebar -m config height)
# yabai -m config external_bar all:$SPACEBAR_HEIGHT:0
#+end_src

These are the things we always want to float:
#+begin_src shell
yabai -m rule --add app='^System Information$' manage=off
yabai -m rule --add app='^System Preferences$' manage=off
yabai -m rule --add title='Preferences$' manage=off
yabai -m rule --add title='Settings$' manage=off
#+end_src

FIN
#+begin_src shell
echo "yabai configuration loaded.."
#+end_src

**** Stacked Spaces
When a space is stacked, these rules apply -- to make it work nicely with
stackline
#+begin_src shell
yabai -m signal --add event=window_created action="~/.config/yabai/refresh.sh"
yabai -m signal --add event=window_destroyed action="~/.config/yabai/refresh.sh"
#+end_src

And of course ~refresh.sh~, which I stole from these two lovely [[https://github.com/AdamWagner/stackline/issues/57#issuecomment-766596737][comm]]-[[https://github.com/AdamWagner/stackline/issues/57#issuecomment-873378890][ents]]:
#+begin_src shell :tangle ~/.config/yabai/refresh.sh :comments link :mkdirp yes :padline no :noweb tangle :cache yes :tangle-mode (identity #o755)
#!/usr/bin/env bash

number_of_windows=$(yabai -m query --windows --space | /usr/local/bin/jq 'length')
number_of_stacked=$(yabai -m query --windows --space | /usr/local/bin/jq -c 'map(select(."stack-index" != 0)) | length')
currspace=$(yabai -m query --spaces --space | /usr/local/bin/jq '.index')

padding=8
spadding=40

[[ "$number_of_windows" -eq 1 ]] && padding=0
[[ "$number_of_stacked" = 0 ]] && spadding=$padding

yabai -m config --space "$currspace" top_padding $padding
yabai -m config --space "$currspace" bottom_padding $padding
yabai -m config --space "$currspace" left_padding $spadding
yabai -m config --space "$currspace" right_padding $spadding
yabai -m config --space "$currspace" window_gap $padding
#+end_src
**** Spaces
***** Comms Space
This is the space for my communication apps, namely Slack, Teams, Signal, and Discord
#+begin_src shell

#+end_src
*** Yabai Utils
* License

#+BEGIN_SRC :tangle no
Literate Dotfiles -- Collection of configuration files written and compiled with org-mode
Copyright (C) 2022 Ian S. Pringle

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <https://www.gnu.org/licenses/>.
#+END_SRC
